#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     compass,        sensorI2CCustom)
#pragma config(Sensor, S3,     accelerometer,  sensorI2CCustom)
#pragma config(Sensor, S4,     irSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,          grabber30L,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          grabber30R,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          grabber60L,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     FL,            tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     FR,            tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     BL,            tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     BR,            tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C3_1,     armLift,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C4_1,    grabber60R,           tServoStandard)
#pragma config(Servo,  srvo_S2_C4_2,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S2_C4_3,    dump30,               tServoStandard)
#pragma config(Servo,  srvo_S2_C4_4,    dump60,               tServoStandard)
#pragma config(Servo,  srvo_S2_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Start Drivers */
#include "JoystickDriver.c" // include file to "handle" the Bluetooth messages
#include "drivers/hitechnic-accelerometer.h" // HiTechnic Acceleration Sensor Driver
#include "drivers/hitechnic-compass.h" // HiTechnic Compass Sensor Driver
#include "drivers/hitechnic-irseeker-v2.h" // HiTechnic IR Seeker V2 Driver

/* End Drivers */

	int xAxis = 0; //acceleration sensor vars
	int yAxis = 0;
	int zAxis = 0;

//DEBUG VARIABLES***********************
int DEBUGencoderValue = 0;
int DEBUGcompass = -1;
int DEBUGaccelx = -1;
int DEBUGaccely = -1;
int DEBUGaccelz = -1;

int initialCompassHeading; // grabs initial heading to be used for compass movement
int desiredCompassHeading;
//int distanceToGo = 12; // distance in inches
//int degreesToTurn = rotations * 360; // how many degrees a wheel rotates

const int ENCODERTICKSPERREVOLUTION = 1120; // 280 * 4
const int GRABBER60RUP = 120; // up position for the grabber60R servo
const int GRABBER60RDOWN = 255; // down position for the grabber60L servo
const int LEGOMOTORTARGET = 160; // sets how far the lego motors move for grabbers

const float WHEELDIAMETER = 4.0; // diameter of the wheel in inches
const float WHEELCIRCUMFERENCE = WHEELDIAMETER * PI; // circumference of the wheel
//float  = distanceToGo / circumference; // how many times does the wheel need to rotate to go the total distance

void initializeRobot() {
	DEBUGcompass = 7;
	initialCompassHeading = HTMCsetTarget(compass);//HTMCsetTarget(compass); //grabs init heading to be used for compass movement
	DEBUGcompass = 3;
	desiredCompassHeading = initialCompassHeading;
	HTACreadAllAxes(accelerometer, DEBUGaccelx, DEBUGaccely, DEBUGaccelz);
	// Reset Motor Encoders
  nMotorEncoder[FL] = 0;
  nMotorEncoder[grabber30L] = 0;
	nMotorEncoder[grabber30R] = 0;
	nMotorEncoder[grabber60L] = 0;
	servo[dump60] = 70; // sets servo to the "closed" position
	servo[dump30] = 190; // sets servo to the "closed" position
  servo[grabber60R] = GRABBER60RUP;
	motor[grabber30L] = 0;
	motor[grabber30R] = 0;
	motor[grabber60L] = 0;

  return;
}

void driveOffRamp() {

}

void driveForwardAccel(int minDistanceInches) {
	xAxis = 0;
	yAxis = 0;
	zAxis = 0;

	// *************************THIS IS JUST A TEST, it will never leave the loop unless you hit something
	motor[FL] = 50;
  motor[FR] = 50;
  motor[BL] = 50;
  motor[BR] = 50;

  nMotorEncoder[FL] = 0;
	int encoderTarget = distanceInches * ENCODERTICKSPERREVOLUTION / WHEELCIRCUMFERENCE;
	
	clearTimer(T2); //use T2 to track how long you've driven
	while(true) {
		HTACreadAllAxes(accelerometer, xAxis, yAxis, zAxis);
		if(xAxis < DEBUGaccelx){//checking lowest X value
			DEBUGaccelx = xAxis;
		}
			if( xAxis > DEBUGaccely){// MAX X value
				DEBUGaccely =xAxis;
			}
    if(xAxis < -200) {//check if you hit something

    	//check that we went the minimum distance (prevents early stops that happen right after start of move
    	if(abs(nMotorEncoder[FL]) > encoderTarget) {
    		//  	hitSomething = true;
    		motor[FL] = 0;
  			motor[FR] = 0;
  			motor[BL] = 0;
  			motor[BR] = 0;
  			return;
  		}
    }
    if(time1(T2) > 10000) { //stop the function if it's been running for more than 10 secs. something has gone wrong
    	motor[FL] = 0;
  		motor[FR] = 0;
  		motor[BL] = 0;
  		motor[BR] = 0;
  		return;
  	}
  }
}

void driveBackwardAccel(int t) {//fix
	xAxis = 0;
	yAxis = 0;
	zAxis = 0;

	// *************************THIS IS JUST A TEST, it will never leave the loop unless you hit something
	motor[FL] = -50;
  motor[FR] = -50;
  motor[BL] = -50;
  motor[BR] = -50;

  nMotorEncoder[FL] = 0;
	int encoderTarget = distanceInches * ENCODERTICKSPERREVOLUTION / WHEELCIRCUMFERENCE;
	
	clearTimer(T2); //use T2 to track how long you've driven
	while(true) {
		HTACreadAllAxes(accelerometer, xAxis, yAxis, zAxis);
		if(xAxis < DEBUGaccelx){//checking lowest X value
			DEBUGaccelx = xAxis;
		}
			if( xAxis > DEBUGaccely){// MAX X value
				DEBUGaccely =xAxis;
			}
    if(xAxis > 200) {//check if you hit something

    	//check that we went the minimum distance (prevents early stops that happen right after start of move
    	if(abs(nMotorEncoder[FL]) > encoderTarget) {
    		//  	hitSomething = true;
    		motor[FL] = 0;
  			motor[FR] = 0;
  			motor[BL] = 0;
  			motor[BR] = 0;
  			return;
  		}
    }
    if(time1(T2) > 10000) { //stop the function if it's been running for more than 10 secs. something has gone wrong
    	motor[FL] = 0;
  		motor[FR] = 0;
  		motor[BL] = 0;
  		motor[BR] = 0;
  		return;
  	}
  }
}

void driveForward(int distanceInches) {
	nMotorEncoder[FL] = 0;
	int encoderTarget = distanceInches * ENCODERTICKSPERREVOLUTION / WHEELCIRCUMFERENCE;

	while(abs(nMotorEncoder[FL]) < encoderTarget) {
		DEBUGencoderValue = nMotorEncoder[FL];
    motor[FL] = 50;
    motor[FR] = 50;
    motor[BL] = 50;
    motor[BR] = 50;
  }

	motor[FL] = 0;
	motor[FR] = 0;
  motor[BL] = 0;
  motor[BR] = 0;
}

void driveBackward(int distanceInches) {
  nMotorEncoder[FL] = 0;
	int encoderTarget = distanceInches * ENCODERTICKSPERREVOLUTION / WHEELCIRCUMFERENCE;

	while(abs(nMotorEncoder[FL]) < encoderTarget) {
    motor[FL] = -50;
    motor[FR] = -50;
    motor[BL] = -50;
    motor[BR] = -50;
  }

	motor[FL] = 0;
	motor[FR] = 0;
  motor[BL] = 0;
  motor[BR] = 0;
}

void grab30() {
  nMotorEncoderTarget[grabber30L] = LEGOMOTORTARGET;
	nMotorEncoderTarget[grabber30R] = LEGOMOTORTARGET;
	motor[grabber30L] = 50;
	motor[grabber30R] = 50;
	wait1Msec(300);
	motor[grabber30L] = 1;
	motor[grabber30R] = 1;
}

void door30() {
  servo[dump30] = 150;
}

void grab60() {
	nMotorEncoderTarget[grabber60L] = LEGOMOTORTARGET;
	motor[grabber60L] = 50;
	servo[grabber60R] = GRABBER60RDOWN;
	wait1Msec(300);
	motor[grabber60L] = 1;
}

void door60() {
  servo[dump60] = 150;
}

void rotateCounterClockwise(int rotationDegrees) {
	desiredCompassHeading = (desiredCompassHeading - rotationDegrees + 360) % 360;

	while(desiredCompassHeading != HTMCreadHeading(compass)) { // rotate counter clockwise until at desired angle
		motor[FL] = -40;
	  motor[FR] = 40;
	  motor[BL] = -40;
	  motor[BR] = 40;
	}

	motor[FL] = 0;
 	motor[FR] = 0;
	motor[BL] = 0;
	motor[BR] = 0;
}

void rotateClockwise(int rotationDegrees) {//note: rotating CW increases compass value
	desiredCompassHeading = (desiredCompassHeading + rotationDegrees + 360) % 360;

	while(desiredCompassHeading != HTMCreadHeading(compass)) { // rotate clockwise until at desired angle
		DEBUGcompass = HTMCreadHeading(compass);
		motor[FL] = 40;
		motor[FR] = -40;
		motor[BL] = 40;
		motor[BR] = -40;
	}

	motor[FL] = 0;
 	motor[FR] = 0;
	motor[BL] = 0;
	motor[BR] = 0;
}

void strafeLeft(int distanceInches) {
	nMotorEncoder[BL] = 0;
	int encoderTarget = distanceInches * ENCODERTICKSPERREVOLUTION / WHEELCIRCUMFERENCE;

	while(abs(nMotorEncoder[BL]) < encoderTarget) {
		DEBUGencoderValue = nMotorEncoder[BL];
    motor[FL] = -50;
    motor[FR] = 50;
    motor[BL] = 50;
    motor[BR] = -50;
  }

	motor[FL] = 0;
	motor[FR] = 0;
  motor[BL] = 0;
  motor[BR] = 0;
}

void strafeRight(int distanceInches) {
	
	nMotorEncoder[FL] = 0;
	int encoderTarget = distanceInches * ENCODERTICKSPERREVOLUTION / WHEELCIRCUMFERENCE;

	while(abs(nMotorEncoder[FL]) < encoderTarget) {
		DEBUGencoderValue = nMotorEncoder[FL];
    motor[FL] = 50;
    motor[FR] = -50;
    motor[BL] = -50;
    motor[BR] = 50;
  }

	motor[FL] = 0;
	motor[FR] = 0;
  motor[BL] = 0;
  motor[BR] = 0;
}

task main()
{
  initializeRobot();

  waitForStart(); // wait for the beginning of autonomous phase
 //while(true){DEBUGcompass = HTMCreadHeading(compass);}
  	driveForwardAccel(60);
  	wait1Msec(1000); //give time for ball to settle after crash
  	DEBUGaccelz = 4855;
  	door30();

	//rotateClockwise(30);
  //driveForward(12);

  /*
  driveOffRamp(); // drive forward using z axis from accelerometer
  rotateCounterClockwise(45); // rotate counter clockwise 45 degrees using compass sensor
  driveForward(); // drive forward 33.95 inches using motor encoders
  rotateClockwise(45); // rotate clockwise 45 degrees using compass sensor
  driveForwardAccel(); // use accelerometer to know robot position/align robot
  grab30(); // grab the 30 centimeter rolling goal
  door30(); // score into the 30 centimeter goal
  driveBackward(); // drive backward 24 inches using motor encoders
  rotateCounterClockwise(90); // rotate counter clockwise 90 degrees using compass sensor
  driveBackwardAccel(); // use accelerometer to know robot position/align robot
  grab60(); // grab the 60 centimeter rolling goal
  door60(); // score into the 60 centimeter goal
  driveForward(); // drive forward 12 inches using motor encoders
  rotateCounterClockwise(90); // rotate counter clockwise 90 degrees using compass sensor
  driveForward(); // drive forward ? inches using motor encoders
  strafeRight(); // strafe right ? inches using motor encoders
  rotateClockwise(45); // rotate clockwise 45 degrees using compass
  driveForward(); // drive forward 24 inches using motor encoders

  */

  wait1Msec(30000); //wait for end of Auto
}
